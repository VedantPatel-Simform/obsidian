# JavaScript Functions - Complete Interview Guide

## Phase 3.1: Function Basics

### What is a Function?

A function in JavaScript is a reusable block of code designed to perform a particular task. Functions are **first-class objects**, meaning they can be treated like any other value.

#### Functions as First-Class Objects

```javascript
// Functions can be assigned to variables
const greet = function(name) {
    return `Hello, ${name}!`;
};

// Functions can be stored in arrays
const operations = [
    function(a, b) { return a + b; },
    function(a, b) { return a * b; }
];

// Functions can be properties of objects
const calculator = {
    add: function(a, b) { return a + b; },
    multiply: function(a, b) { return a * b; }
};

// Functions can be passed as arguments
function executeOperation(operation, a, b) {
    return operation(a, b);
}
```

#### Function as a Data Type

```javascript
console.log(typeof function() {}); // "function"
console.log(function() {} instanceof Function); // true
console.log(function() {} instanceof Object); // true
```

#### Function Properties and Methods

```javascript
function myFunction() {}
myFunction.customProperty = "I'm a custom property";
console.log(myFunction.name); // "myFunction"
console.log(myFunction.length); // 0 (number of parameters)
console.log(myFunction.customProperty); // "I'm a custom property"
```

### Function Declaration

Function declarations are statements that define a function with the specified parameters.

```javascript
function functionName(parameter1, parameter2) {
    // function body
    return value;
}
```

#### Hoisting Behavior

Function declarations are fully hoisted - they can be called before they're defined in the code.

```javascript
console.log(sayHello("John")); // "Hello, John!" - Works!

function sayHello(name) {
    return `Hello, ${name}!`;
}
```

#### Function Statement vs Expression Context

```javascript
// Function statement (declaration)
function myFunc() {
    return "I'm a statement";
}

// Function expression context
const myFunc2 = function() {
    return "I'm an expression";
};

// Function in expression context
if (true) {
    function blockFunc() {
        return "I'm in a block";
    }
}
```

#### Block Scoped in Strict Mode

```javascript
'use strict';
if (true) {
    function blockScoped() {
        return "I'm block scoped in strict mode";
    }
}
// blockScoped(); // ReferenceError in strict mode
```

### Function Expression

Function expressions create functions as part of expressions and are not hoisted.

```javascript
// Anonymous function expression
const anonymous = function() {
    return "I'm anonymous";
};

// Named function expression
const named = function namedFunc() {
    return "I'm named: " + namedFunc.name;
};
```

#### Named vs Anonymous Function Expressions

```javascript
// Anonymous - harder to debug
const anonymous = function() {
    throw new Error("Error in anonymous function");
};

// Named - easier to debug, allows recursion
const factorial = function fact(n) {
    return n <= 1 ? 1 : n * fact(n - 1);
};
```

#### IIFE (Immediately Invoked Function Expression)

```javascript
// Basic IIFE
(function() {
    console.log("IIFE executed immediately!");
})();

// IIFE with parameters
(function(name) {
    console.log(`Hello, ${name}!`);
})("World");

// IIFE with return value
const result = (function() {
    return "I'm returned from IIFE";
})();

// Module pattern using IIFE
const myModule = (function() {
    let privateVar = "I'm private";
    
    return {
        getPrivateVar: function() {
            return privateVar;
        },
        setPrivateVar: function(value) {
            privateVar = value;
        }
    };
})();
```

#### Function Expressions Are Not Hoisted

```javascript
console.log(myFunc); // undefined
console.log(myFunc()); // TypeError: myFunc is not a function

var myFunc = function() {
    return "I'm not hoisted";
};
```

### Arrow Functions

Arrow functions provide a concise syntax for writing functions and have lexical `this` binding.

#### Syntax Variations

```javascript
// Single parameter, single expression
const square = x => x * x;

// Multiple parameters
const add = (a, b) => a + b;

// No parameters
const greet = () => "Hello!";

// Block body
const complexFunction = (x, y) => {
    const result = x * y;
    return result > 10 ? result : 0;
};

// Returning object literal
const createObject = (name, age) => ({ name, age });
```

#### Implicit Return vs Explicit Return

```javascript
// Implicit return (single expression)
const multiply = (a, b) => a * b;

// Explicit return (block body)
const divide = (a, b) => {
    if (b === 0) {
        throw new Error("Division by zero");
    }
    return a / b;
};
```

#### Lexical `this` Binding

```javascript
const person = {
    name: "John",
    regularFunction: function() {
        console.log(this.name); // "John"
        
        // Arrow function inherits 'this' from enclosing scope
        const arrowFunction = () => {
            console.log(this.name); // "John"
        };
        arrowFunction();
    },
    
    arrowMethod: () => {
        console.log(this.name); // undefined (global 'this')
    }
};
```

#### No Arguments Object

```javascript
function regularFunction() {
    console.log(arguments); // Arguments object available
}

const arrowFunction = () => {
    console.log(arguments); // ReferenceError: arguments is not defined
};

// Use rest parameters instead
const arrowWithRest = (...args) => {
    console.log(args); // Array of arguments
};
```

#### Cannot Be Used as Constructors

```javascript
function RegularFunction() {
    this.name = "Regular";
}
const regular = new RegularFunction(); // Works

const ArrowFunction = () => {
    this.name = "Arrow";
};
const arrow = new ArrowFunction(); // TypeError: ArrowFunction is not a constructor
```

#### No Prototype Property

```javascript
function regularFunc() {}
console.log(regularFunc.prototype); // Object with constructor property

const arrowFunc = () => {};
console.log(arrowFunc.prototype); // undefined
```

### Arrow Function vs Function Declaration

|Feature|Function Declaration|Arrow Function|
|---|---|---|
|`this` binding|Dynamic (call-site)|Lexical (definition-site)|
|Hoisting|Fully hoisted|Not hoisted|
|`arguments` object|Available|Not available|
|Constructor usage|Can be used with `new`|Cannot be used with `new`|
|`prototype` property|Has prototype|No prototype|
|Method definitions|Suitable|Not suitable for object methods|

```javascript
// Method definitions comparison
const obj = {
    name: "Object",
    
    // Regular method - 'this' refers to obj
    regularMethod: function() {
        return this.name;
    },
    
    // Arrow method - 'this' refers to global/undefined
    arrowMethod: () => {
        return this.name; // undefined
    }
};

console.log(obj.regularMethod()); // "Object"
console.log(obj.arrowMethod()); // undefined
```

---

## Phase 3.2: Function Features & Syntax

### Rest vs Spread Syntax

#### Rest Parameters (...args)

```javascript
// Rest parameters collect remaining arguments into an array
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// Rest parameters must be last
function mixedParams(first, second, ...rest) {
    console.log(first); // 1
    console.log(second); // 2
    console.log(rest); // [3, 4, 5]
}
mixedParams(1, 2, 3, 4, 5);
```

#### Rest in Destructuring

```javascript
// Array destructuring with rest
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first); // 1
console.log(second); // 2
console.log(rest); // [3, 4, 5]

// Object destructuring with rest
const { name, age, ...otherInfo } = {
    name: "John",
    age: 30,
    city: "New York",
    country: "USA"
};
console.log(name); // "John"
console.log(age); // 30
console.log(otherInfo); // { city: "New York", country: "USA" }
```

#### Spread in Function Calls

```javascript
function add(a, b, c) {
    return a + b + c;
}

const numbers = [1, 2, 3];
console.log(add(...numbers)); // 6

// Spread with Math functions
const nums = [1, 5, 3, 9, 2];
console.log(Math.max(...nums)); // 9
console.log(Math.min(...nums)); // 1
```

#### Spread with Arrays and Objects

```javascript
// Array spread
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// Object spread
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const combined = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }

// Shallow cloning
const originalArray = [1, 2, 3];
const clonedArray = [...originalArray];

const originalObject = { name: "John", age: 30 };
const clonedObject = { ...originalObject };
```

#### Rest vs Arguments Object

```javascript
// arguments object (old way)
function oldWay() {
    console.log(arguments); // Array-like object
    console.log(Array.from(arguments)); // Convert to real array
}

// Rest parameters (modern way)
function modernWay(...args) {
    console.log(args); // Real array
    args.forEach(arg => console.log(arg)); // Array methods available
}
```

### Arguments Object

The `arguments` object is an array-like object accessible inside functions that contains the values of the arguments passed to that function.

#### Array-like Object Properties

```javascript
function demonstrateArguments() {
    console.log(arguments.length); // Number of arguments
    console.log(arguments[0]); // First argument
    console.log(arguments[1]); // Second argument
    
    // Array-like but not an array
    console.log(Array.isArray(arguments)); // false
    console.log(typeof arguments); // "object"
}

demonstrateArguments("hello", "world", 123);
```

#### arguments.length

```javascript
function checkArguments() {
    console.log(`Function received ${arguments.length} arguments`);
    
    for (let i = 0; i < arguments.length; i++) {
        console.log(`Argument ${i}: ${arguments[i]}`);
    }
}

checkArguments(1, 2, 3); // Function received 3 arguments
```

#### arguments.callee (deprecated)

```javascript
// DON'T USE - deprecated in strict mode
function factorial(n) {
    if (n <= 1) return 1;
    return n * arguments.callee(n - 1); // Self-reference
}

// Use named function expressions instead
const factorial = function fact(n) {
    if (n <= 1) return 1;
    return n * fact(n - 1);
};
```

#### Converting to Real Array

```javascript
function convertArguments() {
    // Method 1: Array.from()
    const argsArray1 = Array.from(arguments);
    
    // Method 2: Spread operator
    const argsArray2 = [...arguments];
    
    // Method 3: Array.prototype.slice.call()
    const argsArray3 = Array.prototype.slice.call(arguments);
    
    console.log(argsArray1); // Real array
    console.log(argsArray2); // Real array
    console.log(argsArray3); // Real array
}
```

#### Arrow Functions Don't Have Arguments

```javascript
const arrowFunction = () => {
    console.log(arguments); // ReferenceError
};

// Use rest parameters instead
const arrowWithRest = (...args) => {
    console.log(args); // Works fine
};
```

### Default Parameters

ES6 introduced default parameter syntax, allowing functions to have default values for parameters.

#### ES6 Default Parameter Syntax

```javascript
function greet(name = "World", greeting = "Hello") {
    return `${greeting}, ${name}!`;
}

console.log(greet()); // "Hello, World!"
console.log(greet("John")); // "Hello, John!"
console.log(greet("John", "Hi")); // "Hi, John!"
```

#### Default Parameter Expressions

```javascript
function createUser(name = "Anonymous", id = Math.random()) {
    return { name, id };
}

// Default parameters can be function calls
function processData(data, processor = JSON.parse) {
    return processor(data);
}

// Default parameters can reference other parameters
function createRectangle(width = 1, height = width) {
    return { width, height };
}
```

#### Temporal Dead Zone in Defaults

```javascript
// This works - b can reference a
function example1(a = 1, b = a + 1) {
    return [a, b];
}

// This doesn't work - a can't reference b (TDZ)
function example2(a = b + 1, b = 1) {
    return [a, b]; // ReferenceError: Cannot access 'b' before initialization
}
```

#### undefined vs null with Defaults

```javascript
function testDefaults(value = "default") {
    return value;
}

console.log(testDefaults()); // "default"
console.log(testDefaults(undefined)); // "default"
console.log(testDefaults(null)); // null
console.log(testDefaults(0)); // 0
console.log(testDefaults("")); // ""
```

#### Default Parameters with Destructuring

```javascript
// Object destructuring with defaults
function createUser({ name = "Anonymous", age = 0, city = "Unknown" } = {}) {
    return { name, age, city };
}

console.log(createUser()); // { name: "Anonymous", age: 0, city: "Unknown" }
console.log(createUser({ name: "John" })); // { name: "John", age: 0, city: "Unknown" }

// Array destructuring with defaults
function processCoordinates([x = 0, y = 0] = []) {
    return { x, y };
}

console.log(processCoordinates()); // { x: 0, y: 0 }
console.log(processCoordinates([10])); // { x: 10, y: 0 }
```

### Template Strings (Template Literals)

Template literals provide an easy way to interpolate variables and expressions into strings.

#### Basic Interpolation Syntax

```javascript
const name = "John";
const age = 30;

// Template literal with interpolation
const message = `Hello, my name is ${name} and I'm ${age} years old.`;
console.log(message); // "Hello, my name is John and I'm 30 years old."

// Comparison with string concatenation
const oldWay = "Hello, my name is " + name + " and I'm " + age + " years old.";
```

#### Multi-line Strings

```javascript
const multiline = `
    This is a multi-line string.
    It preserves line breaks and
    indentation.
`;

const html = `
    <div>
        <h1>Title</h1>
        <p>This is a paragraph.</p>
    </div>
`;
```

#### Expression Evaluation

```javascript
const a = 5;
const b = 10;

console.log(`The sum of ${a} and ${b} is ${a + b}.`); // "The sum of 5 and 10 is 15."
console.log(`Today is ${new Date().toDateString()}`); // Current date

// Function calls in template literals
function formatCurrency(amount) {
    return `$${amount.toFixed(2)}`;
}

const price = 29.99;
console.log(`The price is ${formatCurrency(price)}`); // "The price is $29.99"
```

#### Tagged Template Literals

```javascript
function highlight(strings, ...values) {
    return strings.reduce((result, string, index) => {
        const value = values[index] ? `<strong>${values[index]}</strong>` : '';
        return result + string + value;
    }, '');
}

const name = "John";
const age = 30;
const tagged = highlight`Hello, my name is ${name} and I'm ${age} years old.`;
console.log(tagged); // "Hello, my name is <strong>John</strong> and I'm <strong>30</strong> years old."
```

#### Raw Strings with String.raw()

```javascript
const filePath = String.raw`C:\Users\John\Documents\file.txt`;
console.log(filePath); // "C:\Users\John\Documents\file.txt"

// Without String.raw(), backslashes would be interpreted as escape characters
const normalString = `C:\Users\John\Documents\file.txt`;
console.log(normalString); // Escape sequences would be processed
```

### Destructuring

Destructuring allows unpacking values from arrays or properties from objects into distinct variables.

#### Array Destructuring

```javascript
const numbers = [1, 2, 3, 4, 5];

// Basic destructuring
const [first, second] = numbers;
console.log(first); // 1
console.log(second); // 2

// Skipping elements
const [, , third] = numbers;
console.log(third); // 3

// Rest in destructuring
const [head, ...tail] = numbers;
console.log(head); // 1
console.log(tail); // [2, 3, 4, 5]
```

#### Object Destructuring

```javascript
const person = {
    name: "John",
    age: 30,
    city: "New York",
    country: "USA"
};

// Basic destructuring
const { name, age } = person;
console.log(name); // "John"
console.log(age); // 30

// Renaming variables
const { name: fullName, age: years } = person;
console.log(fullName); // "John"
console.log(years); // 30

// Rest in object destructuring
const { name, ...otherInfo } = person;
console.log(name); // "John"
console.log(otherInfo); // { age: 30, city: "New York", country: "USA" }
```

#### Nested Destructuring

```javascript
const user = {
    id: 1,
    name: "John",
    address: {
        street: "123 Main St",
        city: "New York",
        coordinates: {
            lat: 40.7128,
            lng: -74.0060
        }
    }
};

// Nested object destructuring
const {
    name,
    address: {
        city,
        coordinates: { lat, lng }
    }
} = user;

console.log(name); // "John"
console.log(city); // "New York"
console.log(lat); // 40.7128
console.log(lng); // -74.0060
```

#### Default Values in Destructuring

```javascript
const person = { name: "John" };

// Default values
const { name, age = 25, city = "Unknown" } = person;
console.log(name); // "John"
console.log(age); // 25
console.log(city); // "Unknown"

// Array destructuring with defaults
const [a = 1, b = 2, c = 3] = [];
console.log(a, b, c); // 1 2 3
```

#### Parameter Destructuring

```javascript
// Object parameter destructuring
function createUser({ name, age, email = "not provided" }) {
    return `User: ${name}, Age: ${age}, Email: ${email}`;
}

const userData = { name: "John", age: 30 };
console.log(createUser(userData)); // "User: John, Age: 30, Email: not provided"

// Array parameter destructuring
function calculateDistance([x1, y1], [x2, y2]) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

console.log(calculateDistance([0, 0], [3, 4])); // 5
```

#### Swapping Variables

```javascript
let a = 1;
let b = 2;

// Swap without destructuring (old way)
let temp = a;
a = b;
b = temp;

// Swap with destructuring (modern way)
[a, b] = [b, a];
console.log(a); // 2
console.log(b); // 1
```

### Function.length / Function.name

#### Function.length (Arity)

The `length` property indicates the number of parameters expected by the function.

```javascript
function noParams() {}
function oneParam(a) {}
function twoParams(a, b) {}
function threeParams(a, b, c) {}

console.log(noParams.length); // 0
console.log(oneParam.length); // 1
console.log(twoParams.length); // 2
console.log(threeParams.length); // 3
```

#### Impact of Default Parameters on Length

```javascript
function withDefaults(a, b = 2, c) {}
function withoutDefaults(a, b, c) {}

console.log(withDefaults.length); // 1 (only counts parameters before first default)
console.log(withoutDefaults.length); // 3
```

#### Rest Parameters Impact on Length

```javascript
function withRest(a, b, ...rest) {}
function withoutRest(a, b, c) {}

console.log(withRest.length); // 2 (rest parameters don't count)
console.log(withoutRest.length); // 3
```

#### Function.name Property

```javascript
// Named function declaration
function myFunction() {}
console.log(myFunction.name); // "myFunction"

// Named function expression
const namedExpression = function myFunc() {};
console.log(namedExpression.name); // "myFunc"

// Anonymous function expression
const anonymous = function() {};
console.log(anonymous.name); // "anonymous" (inferred from variable name)

// Arrow function
const arrow = () => {};
console.log(arrow.name); // "arrow"
```

#### Inferred Names

```javascript
const obj = {
    method() {},
    property: function() {}
};

console.log(obj.method.name); // "method"
console.log(obj.property.name); // "property"

// Array of functions
const funcs = [
    function first() {},
    function second() {}
];

console.log(funcs[0].name); // "first"
console.log(funcs[1].name); // "second"
```

---

## Phase 3.3: Functions as Objects & Advanced Concepts

### Function as an Object

Functions in JavaScript are objects, which means they can have properties and methods.

#### Functions Have Properties and Methods

```javascript
function myFunction() {
    return "Hello World";
}

// Add custom properties
myFunction.customProperty = "I'm a custom property";
myFunction.callCount = 0;

// Add custom methods
myFunction.incrementCount = function() {
    this.callCount++;
};

console.log(myFunction.customProperty); // "I'm a custom property"
myFunction.incrementCount();
console.log(myFunction.callCount); // 1
```

#### Function.prototype.call(), apply(), bind()

##### call() Method

```javascript
function greet(greeting, punctuation) {
    return `${greeting}, ${this.name}${punctuation}`;
}

const person = { name: "John" };

// call() - invoke function with specific 'this' and individual arguments
console.log(greet.call(person, "Hello", "!")); // "Hello, John!"
console.log(greet.call(person, "Hi", ".")); // "Hi, John."
```

##### apply() Method

```javascript
function sum(a, b, c) {
    console.log(`this.multiplier: ${this.multiplier}`);
    return (a + b + c) * this.multiplier;
}

const context = { multiplier: 2 };
const numbers = [1, 2, 3];

// apply() - invoke function with specific 'this' and array of arguments
console.log(sum.apply(context, numbers)); // 12 (6 * 2)

// Useful for finding max/min in arrays
const nums = [1, 5, 3, 9, 2];
console.log(Math.max.apply(null, nums)); // 9
```

##### bind() Method

```javascript
function multiply(a, b) {
    return a * b * this.factor;
}

const context = { factor: 10 };

// bind() - create new function with specific 'this' and optionally preset arguments
const boundMultiply = multiply.bind(context);
console.log(boundMultiply(2, 3)); // 60

// Partial application with bind
const multiplyByTen = multiply.bind(context, 10);
console.log(multiplyByTen(5)); // 500

// Practical example: event handlers
class Button {
    constructor(element) {
        this.element = element;
        this.clickCount = 0;
        
        // Bind 'this' to maintain context
        this.element.addEventListener('click', this.handleClick.bind(this));
    }
    
    handleClick() {
        this.clickCount++;
        console.log(`Button clicked ${this.clickCount} times`);
    }
}
```

#### Custom Properties on Functions

```javascript
function cache(fn) {
    cache.results = cache.results || {};
    
    return function(...args) {
        const key = JSON.stringify(args);
        if (key in cache.results) {
            console.log("Cache hit!");
            return cache.results[key];
        }
        
        const result = fn.apply(this, args);
        cache.results[key] = result;
        return result;
    };
}

const expensiveFunction = cache(function(n) {
    console.log("Computing...");
    return n * n;
});

console.log(expensiveFunction(5)); // Computing... 25
console.log(expensiveFunction(5)); // Cache hit! 25
```

#### Function Constructors

```javascript
// Function constructor (not recommended)
const add = new Function('a', 'b', 'return a + b');
console.log(add(2, 3)); // 5

// Regular function constructor
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    return `Hello, I'm ${this.name}`;
};

const john = new Person("John", 30);
console.log(john.greet()); // "Hello, I'm John"
```

### Higher Order Functions

Higher-order functions are functions that operate on other functions, either by taking them as arguments or by returning them.

#### Functions That Accept Functions as Arguments

```javascript
// Basic higher-order function
function applyOperation(a, b, operation) {
    return operation(a, b);
}

const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

console.log(applyOperation(5, 3, add)); // 8
console.log(applyOperation(5, 3, multiply)); // 15

// Array methods are higher-order functions
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(x => x * 2); // [2, 4, 6, 8, 10]
const evens = numbers.filter(x => x % 2 === 0); // [2, 4]
const sum = numbers.reduce((acc, x) => acc + x, 0); // 15
```

#### Functions That Return Functions

```javascript
// Function factory
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// Configuration function
function createValidator(config) {
    return function(value) {
        if (config.required && !value) {
            return "Value is required";
        }
        if (config.minLength && value.length < config.minLength) {
            return `Value must be at least ${config.minLength} characters`;
        }
        return null; // Valid
    };
}

const nameValidator = createValidator({ required: true, minLength: 2 });
console.log(nameValidator("")); // "Value is required"
console.log(nameValidator("A")); // "Value must be at least 2 characters"
console.log(nameValidator("John")); // null
```

#### Common Patterns (map, filter, reduce)

```javascript
const users = [
    { name: "John", age: 30, active: true },
    { name: "Jane", age: 25, active: false },
    { name: "Bob", age: 35, active: true }
];

// Map - transform each element
const names = users.map(user => user.name);
console.log(names); // ["John", "Jane", "Bob"]

// Filter - select elements based on condition
const activeUsers = users.filter(user => user.active);
console.log(activeUsers); // [{ name: "John", age: 30, active: true }, { name: "Bob", age: 35, active: true }]

// Reduce - accumulate values
const totalAge = users.reduce((sum, user) => sum + user.age, 0);
console.log(totalAge); // 90

// Chaining higher-order functions
const activeUserNames = users
    .filter(user => user.active)
    .map(user => user.name);
console.log(activeUserNames); // ["John", "Bob"]
```

#### Callback Functions

```javascript
// Asynchronous callback
function fetchData(callback) {
    setTimeout(() => {
        const data = { id: 1, name: "John" };
        callback(null, data);
    }, 1000);
}

fetchData((error, data) => {
    if (error) {
        console.error("Error:", error);
    } else {
        console.log("Data:", data);
    }
});

// Event callback
function addEventListener(element, event, callback) {
    element.addEventListener(event, callback);
}

// Usage
const button = document.getElementById('myButton');
addEventListener(button, 'click', function() {
    console.log('Button clicked!');
});
```

#### Function Composition

```javascript
// Basic composition
const add = x => y => x + y;
const multiply = x => y => x * y;
const square = x => x * x;

// Compose functions
const compose = (f, g) => x => f(g(x));

const addFiveThenSquare = compose(square, add(5));
console.log(addFiveThenSquare(3)); // 64 ((3 + 5)^2)

// Advanced composition
const pipe = (...functions) => value => 
    functions.reduce((acc, fn) => fn(acc), value);

const processNumber = pipe(
    x => x + 1,
    x => x * 2,
    x => x - 3
);

console.log(processNumber(5)); // 9 ((5 + 1) * 2 - 3)
```

### Why Functions Are Called First-Class Citizens

Functions are first-class citizens because they support all the operations generally available to other entities:

#### Can Be Stored in Variables

```javascript
const myFunction = function() {
    return "Stored in variable";
};

let dynamicFunction;
if (Math.random() > 0.5) {
    dynamicFunction = () => "Random function A";
} else {
    dynamicFunction = () => "Random function B";
}
```

#### Can Be Passed as Arguments

```javascript
function executeCallback(callback, data) {
    return callback(data);
}

const processor = data => data.toUpperCase();
console.log(executeCallback(processor, "hello")); // "HELLO"

// Array methods demonstrate this
[1, 2, 3].forEach(console.log); // Passing console.log as argument
```

#### Can Be Returned from Functions

```javascript
function createFunction(type) {
    if (type === 'greet') {
        return name => `Hello, ${name}!`;
    } else if (type === 'farewell') {
        return name => `Goodbye, ${name}!`;
    }
}

const greetFunction = createFunction('greet');
console.log(greetFunction("John")); // "Hello, John!"
```

#### Can Be Stored in Data Structures

```javascript
// In arrays
const operations = [
    (a, b) => a + b,
    (a, b) => a - b,
    (a, b) => a * b,
    (a, b) => a / b
];

console.log(operations[0](5, 3)); // 8

// In objects
const calculator = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b,
    divide: (a, b) => a / b
};

console.log(calculator.multiply(4, 5)); // 20

// In Maps
const functionMap = new Map();
functionMap.set('double', x => x * 2);
functionMap.set('square', x => x * x);

console.log(functionMap.get('double')(5)); // 10
```

#### Can Be Created at Runtime

```javascript
function createDynamicFunction(operation) {
    switch(operation) {
        case 'add':
            return (a, b) => a + b;
        case 'multiply':
            return (a, b) => a * b;
        default:
            return () => 0;
    }
}

const userChoice = 'add'; // Could come from user input
const dynamicFunc = createDynamicFunction(userChoice);
console.log(dynamicFunc(3, 4)); // 7
```

#### Can Have Properties and Methods

```javascript
function smartFunction() {
    smartFunction.callCount = (smartFunction.callCount || 0) + 1;
    return `Called ${smartFunction.callCount} times`;
}

smartFunction.reset = function() {
    this.callCount = 0;
};

console.log(smartFunction()); // "Called 1 times"
console.log(smartFunction()); // "Called 2 times"
smartFunction.reset();
console.log(smartFunction()); // "Called 1 times"
```

### Pure and Impure Functions

#### Pure Function Definition

A pure function is a function that:

1. Always returns the same output for the same input
2. Has no side effects (doesn't modify external state)

```javascript
// Pure function examples
const add = (a, b) => a + b;
const multiply = (x, y) => x * y;
const getLength = str => str.length;

// Always same output for same input
console.log(add(2, 3)); // Always 5
console.log(add(2, 3)); // Always 5

// Pure function with objects (no mutation)
const addProperty = (obj, key, value) => ({
    ...obj,
    [key]: value
});

const original = { name: "John" };
const updated = addProperty(original, "age", 30);
console.log(original); // { name: "John" } - unchanged
console.log(updated); // { name: "John", age: 30 }
```

#### Same Input, Same Output

```javascript
// Pure - predictable
const calculateTax = (amount, rate) => amount * rate;

// Impure - depends on external state
let taxRate = 0.1;
const calculateTaxImpure = (amount) => amount * taxRate;

console.log(calculateTax(100, 0.1)); // Always 10
console.log(calculateTaxImpure(100)); // Depends on taxRate value
```

#### No Side Effects

```javascript
// Pure - no side effects
const createUser = (name, age) => ({ name, age, id: Math.random() });

// Impure - side effects
let userDatabase = [];
const addUser = (name, age) => {
    const user = { name, age, id: Math.random() };
    userDatabase.push(user); // Side effect - modifies external state
    return user;
};

// Pure alternative
const addUserPure = (database, name, age) => {
    const user = { name, age, id: Math.random() };
    return [...database, user]; // Returns new array
};
```

#### Referential Transparency

```javascript
// Referentially transparent - can replace function call with its result
const double = x => x * 2;
const result = double(5) + double(3); // Can be replaced with 10 + 6

// Not referentially transparent
const getRandomDouble = x => x * Math.random();
const result2 = getRandomDouble(5) + getRandomDouble(3); // Cannot be simplified
```

#### Benefits of Pure Functions

```javascript
// 1. Easier to test
const add = (a, b) => a + b;
// Test: assert(add(2, 3) === 5) - always passes

// 2. Easier to reason about
const isEven = n => n % 2 === 0;
// You always know what this function does

// 3. Can be memoized (cached)
const memoize = (fn) => {
    const cache = {};
    return (...args) => {
        const key = JSON.stringify(args);
        if (cache[key]) {
            return cache[key];
        }
        const result = fn(...args);
        cache[key] = result;
        return result;
    };
};

const expensivePureFunction = memoize((n) => {
    // Expensive computation
    return n * n * n;
});

// 4. Safe for parallel execution
const numbers = [1, 2, 3, 4, 5];
const squared = numbers.map(x => x * x); // Pure, safe for parallel processing
```

#### Impure Function Examples

```javascript
// Impure - modifies external state
let counter = 0;
const increment = () => ++counter;

// Impure - depends on external state
const getCurrentTime = () => new Date().toISOString();

// Impure - I/O operations
const logMessage = (message) => {
    console.log(message); // Side effect
    return message;
};

// Impure - network requests
const fetchUser = async (id) => {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
};

// Impure - DOM manipulation
const updateElement = (id, text) => {
    document.getElementById(id).textContent = text;
};
```

#### Side Effects Identification

```javascript
// Common side effects to watch for:

// 1. Modifying global variables
let globalVar = 0;
const impure1 = () => globalVar++; // Side effect

// 2. Modifying input parameters
const impure2 = (arr) => {
    arr.push(1); // Mutates input
    return arr;
};

// 3. I/O operations
const impure3 = (data) => {
    localStorage.setItem('data', JSON.stringify(data)); // Side effect
    return data;
};

// 4. Network requests
const impure4 = async (url) => {
    return await fetch(url); // Side effect
};

// 5. DOM manipulation
const impure5 = (message) => {
    document.body.innerHTML += message; // Side effect
    return message;
};

// Pure alternatives
const pure1 = (count) => count + 1;
const pure2 = (arr) => [...arr, 1];
const pure3 = (data) => ({ data, serialized: JSON.stringify(data) });
```

### Function Currying

Currying is the technique of converting a function that takes multiple arguments into a sequence of functions that each take a single argument.

#### Currying Definition and Concept

```javascript
// Regular function
function add(a, b, c) {
    return a + b + c;
}

// Curried version
function addCurried(a) {
    return function(b) {
        return function(c) {
            return a + b + c;
        };
    };
}

// Arrow function curried version
const addCurriedArrow = a => b => c => a + b + c;

// Usage
console.log(add(1, 2, 3)); // 6
console.log(addCurried(1)(2)(3)); // 6
console.log(addCurriedArrow(1)(2)(3)); // 6
```

#### Partial Application vs Currying

```javascript
// Partial Application - fixing some arguments
function multiply(a, b, c) {
    return a * b * c;
}

const multiplyByTwo = multiply.bind(null, 2);
console.log(multiplyByTwo(3, 4)); // 24 (2 * 3 * 4)

// Currying - transforming to single-argument functions
const multiplyCurried = a => b => c => a * b * c;
const multiplyByTwoCurried = multiplyCurried(2);
const multiplyByTwoAndThree = multiplyByTwoCurried(3);
console.log(multiplyByTwoAndThree(4)); // 24

// Partial application can take multiple arguments at once
// Currying always takes one argument at a time
```

#### Manual Currying Implementation

```javascript
// Manual currying for 2 arguments
function curry2(fn) {
    return function(a) {
        return function(b) {
            return fn(a, b);
        };
    };
}

// Manual currying for 3 arguments
function curry3(fn) {
    return function(a) {
        return function(b) {
            return function(c) {
                return fn(a, b, c);
            };
        };
    };
}

// Generic curry function
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...nextArgs) {
                return curried.apply(this, args.concat(nextArgs));
            };
        }
    };
}

// Usage
const add = (a, b, c) => a + b + c;
const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
console.log(curriedAdd(1, 2, 3)); // 6
```

#### Automatic Currying

```javascript
// Lodash curry example (conceptual)
function autoCurry(fn, arity = fn.length) {
    return function curried(...args) {
        if (args.length >= arity) {
            return fn(...args);
        }
        return curried.bind(null, ...args);
    };
}

const multiply = (a, b, c, d) => a * b * c * d;
const curriedMultiply = autoCurry(multiply);

const step1 = curriedMultiply(2);
const step2 = step1(3);
const step3 = step2(4);
const result = step3(5);
console.log(result); // 120

// Or all at once
console.log(curriedMultiply(2)(3)(4)(5)); // 120
console.log(curriedMultiply(2, 3)(4, 5)); // 120
```

#### Use Cases and Benefits

```javascript
// 1. Configuration functions
const createValidator = type => config => value => {
    switch(type) {
        case 'string':
            return typeof value === 'string' && 
                   value.length >= (config.minLength || 0);
        case 'number':
            return typeof value === 'number' && 
                   value >= (config.min || 0);
        default:
            return false;
    }
};

const stringValidator = createValidator('string');
const nameValidator = stringValidator({ minLength: 2 });
const emailValidator = stringValidator({ minLength: 5 });

console.log(nameValidator("John")); // true
console.log(emailValidator("a@b")); // false

// 2. Event handling
const handleEvent = eventType => selector => handler => {
    document.querySelector(selector).addEventListener(eventType, handler);
};

const onClick = handleEvent('click');
const onClickButton = onClick('#myButton');
onClickButton(() => console.log('Button clicked!'));

// 3. API calls
const apiCall = method => endpoint => data => {
    return fetch(endpoint, {
        method: method,
        headers: { 'Content-Type': 'application/json' },
        body: data ? JSON.stringify(data) : undefined
    });
};

const get = apiCall('GET');
const post = apiCall('POST');
const getUsers = get('/api/users');
const createUser = post('/api/users');

// Usage
getUsers().then(response => response.json());
createUser({ name: 'John', age: 30 });

// 4. Mathematical operations
const calculate = operation => a => b => {
    switch(operation) {
        case 'add': return a + b;
        case 'multiply': return a * b;
        case 'power': return Math.pow(a, b);
        default: return 0;
    }
};

const add = calculate('add');
const multiply = calculate('multiply');
const power = calculate('power');

const add5 = add(5);
const multiplyBy3 = multiply(3);
const square = power(2);

console.log(add5(10)); // 15
console.log(multiplyBy3(4)); // 12
console.log(square(5)); // 25
```

#### Function.prototype.bind() for Currying

```javascript
// Using bind for partial application (similar to currying)
function greet(greeting, name, punctuation) {
    return `${greeting}, ${name}${punctuation}`;
}

// Partial application with bind
const sayHello = greet.bind(null, 'Hello');
const sayHelloToJohn = sayHello.bind(null, 'John');

console.log(sayHello('World', '!')); // "Hello, World!"
console.log(sayHelloToJohn('.')); // "Hello, John."

// Bind for method currying
const person = {
    name: 'John',
    greet: function(greeting, punctuation) {
        return `${greeting}, ${this.name}${punctuation}`;
    }
};

const johnGreet = person.greet.bind(person);
const johnSayHello = johnGreet.bind(null, 'Hello');

console.log(johnSayHello('!')); // "Hello, John!"

// Advanced bind currying
Function.prototype.curry = function(numArgs) {
    const fn = this;
    numArgs = numArgs || fn.length;
    
    return function curried(...args) {
        if (args.length >= numArgs) {
            return fn.apply(this, args);
        }
        return curried.bind(this, ...args);
    };
};

const sum = function(a, b, c) {
    return a + b + c;
};

const curriedSum = sum.curry();
console.log(curriedSum(1)(2)(3)); // 6
```

---

## Common Interview Questions

### 1. Explain the difference between function declarations and function expressions

**Answer:** Function declarations are hoisted completely and can be called before they're defined. Function expressions are not hoisted and create functions as part of expressions.

### 2. What is the difference between `call`, `apply`, and `bind`?

**Answer:**

- `call()`: Invokes function with specific `this` and individual arguments
- `apply()`: Invokes function with specific `this` and array of arguments
- `bind()`: Returns new function with specific `this` and optionally preset arguments

### 3. What are arrow functions and how do they differ from regular functions?

**Answer:** Arrow functions have lexical `this` binding, no `arguments` object, cannot be constructors, have no `prototype` property, and are not hoisted.

### 4. What is function currying and why is it useful?

**Answer:** Currying transforms a function taking multiple arguments into a sequence of functions each taking a single argument. It enables partial application, function composition, and reusable specialized functions.

### 5. What makes JavaScript functions "first-class citizens"?

**Answer:** Functions can be stored in variables, passed as arguments, returned from functions, stored in data structures, created at runtime, and have properties/methods.

### 6. Explain pure vs impure functions

**Answer:** Pure functions always return the same output for the same input and have no side effects. Impure functions may depend on external state or cause side effects.

### 7. What is the difference between rest and spread operators?

**Answer:** Rest (`...args`) collects multiple elements into an array. Spread (`...array`) expands an array into individual elements.

### 8. How does the `arguments` object work?

**Answer:** `arguments` is an array-like object containing all arguments passed to a function. It's not available in arrow functions - use rest parameters instead.

### 9. What are higher-order functions?

**Answer:** Functions that operate on other functions by taking them as arguments or returning them. Examples include `map`, `filter`, `reduce`.

### 10. Explain IIFE and its use cases

**Answer:** Immediately Invoked Function Expression executes immediately when defined. Used for module pattern, avoiding global pollution, and creating private scope.

---

This comprehensive guide covers all the essential JavaScript function concepts you'll need for technical interviews at large MNCs. Make sure to practice writing and explaining these concepts with code examples!