# Complete PostgreSQL Query Optimization Course

## 1. Understanding Query Execution

### Query Execution Process

PostgreSQL follows this execution order:

1. **Parsing**: Syntax validation
2. **Planning**: Query planner creates execution plan
3. **Optimization**: Cost-based optimization
4. **Execution**: Physical execution of the plan

### EXPLAIN Command Mastery

**Basic EXPLAIN Usage:**

```sql
-- Basic explain
EXPLAIN SELECT * FROM users WHERE age > 25;

-- Detailed explain with actual execution
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT * FROM users WHERE age > 25;
```

**Reading EXPLAIN Output:**

```sql
-- Example output interpretation
EXPLAIN (ANALYZE, BUFFERS)
SELECT u.name, o.total
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.age > 30;

/*
Nested Loop  (cost=0.29..8.32 rows=1 width=36) (actual time=0.123..0.456 rows=25 loops=1)
  Buffers: shared hit=15
  ->  Seq Scan on users u  (cost=0.00..4.25 rows=1 width=32) (actual time=0.089..0.234 rows=12 loops=1)
        Filter: (age > 30)
        Rows Removed by Filter: 88
        Buffers: shared hit=3
  ->  Index Scan using orders_user_id_idx on orders o  (cost=0.29..4.06 rows=1 width=12) (actual time=0.012..0.015 rows=2 loops=12)
        Index Cond: (user_id = u.id)
        Buffers: shared hit=12
Planning Time: 0.234 ms
Execution Time: 0.567 ms
*/
```

**Key Metrics to Monitor:**

- **Cost**: Estimated resource usage (lower is better)
- **Rows**: Estimated vs actual row counts
- **Time**: Planning vs execution time
- **Buffers**: Memory usage patterns
- **Loops**: Number of iterations

### Common Execution Nodes

**Sequential Scan (Seq Scan):**

```sql
-- Problematic - full table scan
SELECT * FROM large_table WHERE uncommon_condition = 'rare_value';

-- Solution - add index
CREATE INDEX idx_large_table_condition ON large_table(uncommon_condition);
```

**Index Scan vs Index Only Scan:**

```sql
-- Index scan (needs heap lookup)
SELECT id, name FROM users WHERE email = 'john@example.com';

-- Index only scan (all data in index)
CREATE INDEX idx_users_email_name ON users(email) INCLUDE (name);
SELECT name FROM users WHERE email = 'john@example.com';
```

---

## 2. Index Optimization

### Index Types and Use Cases

**B-Tree Indexes (Default):**

```sql
-- Standard B-tree index
CREATE INDEX idx_users_last_name ON users(last_name);

-- Composite index (order matters!)
CREATE INDEX idx_users_age_city ON users(age, city);

-- Partial index
CREATE INDEX idx_active_users_email ON users(email) WHERE active = true;

-- Expression index
CREATE INDEX idx_users_lower_email ON users(lower(email));
```

**Hash Indexes:**

```sql
-- Good for equality comparisons only
CREATE INDEX CONCURRENTLY idx_users_id_hash ON users USING HASH(id);

-- ❌ DON'T use hash indexes for range queries
-- ✅ DO use for exact matches in high-cardinality columns
```

**GIN Indexes:**

```sql
-- For array operations
CREATE INDEX idx_tags_gin ON posts USING GIN(tags);
SELECT * FROM posts WHERE tags @> ARRAY['postgresql', 'optimization'];

-- For full-text search
CREATE INDEX idx_content_fts ON articles USING GIN(to_tsvector('english', content));
SELECT * FROM articles WHERE to_tsvector('english', content) @@ to_tsquery('postgresql & optimization');
```

**GiST Indexes:**

```sql
-- For geometric data
CREATE INDEX idx_locations_gist ON locations USING GIST(coordinates);

-- For text similarity
CREATE EXTENSION pg_trgm;
CREATE INDEX idx_names_similarity ON users USING GIST(name gist_trgm_ops);
SELECT * FROM users WHERE name % 'Jon Doe';
```

### Index Design Best Practices

**Multi-Column Index Order:**

```sql
-- ✅ CORRECT: Most selective column first
CREATE INDEX idx_orders_status_date ON orders(status, created_date);
-- Query: WHERE status = 'pending' AND created_date > '2024-01-01'

-- ❌ INCORRECT: Less selective column first
CREATE INDEX idx_orders_date_status ON orders(created_date, status);
-- Same query will be less efficient
```

**Covering Indexes:**

```sql
-- Include additional columns to avoid heap lookups
CREATE INDEX idx_users_email_covering
ON users(email) INCLUDE (first_name, last_name, created_at);

-- This query becomes index-only scan
SELECT first_name, last_name, created_at
FROM users
WHERE email = 'user@example.com';
```

**Partial Indexes for Filtered Queries:**

```sql
-- Instead of indexing all rows
CREATE INDEX idx_all_orders ON orders(status);

-- Index only relevant rows
CREATE INDEX idx_pending_orders ON orders(created_date) WHERE status = 'pending';
CREATE INDEX idx_active_users ON users(last_login) WHERE active = true;
```

### Index Maintenance

**Monitoring Index Usage:**

```sql
-- Check index usage statistics
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;

-- Find unused indexes
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0;
```

**Index Bloat Management:**

```sql
-- Check index bloat
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as size,
    round(100 * (pg_relation_size(indexrelid)::numeric /
          (8192 * relpages::numeric)), 2) as bloat_ratio
FROM pg_stat_user_indexes
JOIN pg_class ON pg_class.oid = indexrelid
ORDER BY pg_relation_size(indexrelid) DESC;

-- Rebuild bloated indexes
REINDEX INDEX CONCURRENTLY idx_bloated_index;
```

### Common Index Pitfalls

**❌ DON'T:**

```sql
-- Don't create indexes on every column
CREATE INDEX idx_users_col1 ON users(column1);
CREATE INDEX idx_users_col2 ON users(column2);
CREATE INDEX idx_users_col3 ON users(column3);

-- Don't ignore composite index column order
CREATE INDEX idx_wrong_order ON orders(created_date, status, user_id);
-- Query: WHERE user_id = 1 AND status = 'pending' (won't use index efficiently)

-- Don't use indexes on low-cardinality columns
CREATE INDEX idx_gender ON users(gender); -- Only 2-3 distinct values

-- Don't use functions in WHERE without expression indexes
SELECT * FROM users WHERE UPPER(name) = 'JOHN'; -- Won't use index on name
```

**✅ DO:**

```sql
-- Create strategic composite indexes
CREATE INDEX idx_orders_user_status_date ON orders(user_id, status, created_date);

-- Use expression indexes for functional queries
CREATE INDEX idx_users_upper_name ON users(UPPER(name));
SELECT * FROM users WHERE UPPER(name) = 'JOHN';

-- Create partial indexes for common filtered queries
CREATE INDEX idx_recent_orders ON orders(created_date)
WHERE created_date > CURRENT_DATE - INTERVAL '30 days';
```

---

## 3. Query Structure Optimization

### SELECT Statement Optimization

**Column Selection:**

```sql
-- ❌ DON'T select unnecessary columns
SELECT * FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.active = true;

-- ✅ DO select only needed columns
SELECT u.name, u.email, o.total, o.created_date
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.active = true;
```

**DISTINCT Optimization:**

```sql
-- ❌ INEFFICIENT: DISTINCT on large result set
SELECT DISTINCT user_id FROM orders WHERE created_date > '2024-01-01';

-- ✅ EFFICIENT: Use EXISTS or GROUP BY
SELECT user_id FROM orders
WHERE created_date > '2024-01-01'
GROUP BY user_id;

-- Or use EXISTS with correlated subquery
SELECT u.id FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.user_id = u.id
    AND o.created_date > '2024-01-01'
);
```

### UNION vs UNION ALL

**Performance Difference:**

```sql
-- ❌ SLOWER: UNION removes duplicates (requires sorting)
SELECT name FROM customers WHERE country = 'USA'
UNION
SELECT name FROM customers WHERE country = 'Canada';

-- ✅ FASTER: UNION ALL keeps duplicates
SELECT name FROM customers WHERE country = 'USA'
UNION ALL
SELECT name FROM customers WHERE country = 'Canada';
```

### CASE Statements Optimization

**Efficient CASE Usage:**

```sql
-- ❌ INEFFICIENT: Multiple CASE statements
SELECT
    name,
    CASE WHEN age < 18 THEN 'Minor' ELSE 'Adult' END as age_group,
    CASE WHEN age < 18 THEN 0 ELSE 1 END as can_vote
FROM users;

-- ✅ EFFICIENT: Combined logic
SELECT
    name,
    CASE
        WHEN age < 18 THEN 'Minor'
        ELSE 'Adult'
    END as age_group,
    (age >= 18)::int as can_vote
FROM users;
```

---

## 4. JOIN Optimization

### JOIN Types and Performance

**INNER JOIN Optimization:**

```sql
-- ✅ PROPER: Join on indexed columns
SELECT u.name, o.total
FROM users u
INNER JOIN orders o ON u.id = o.user_id  -- Both columns should be indexed
WHERE u.active = true;

-- ✅ OPTIMAL: Filter early with WHERE
SELECT u.name, o.total
FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE u.active = true  -- Filter applied before join
  AND o.status = 'completed';
```

**LEFT JOIN Pitfalls:**

```sql
-- ❌ PROBLEMATIC: Filtering LEFT JOIN in WHERE
SELECT u.name, o.total
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.status = 'completed';  -- This makes it an INNER JOIN!

-- ✅ CORRECT: Filter in JOIN condition
SELECT u.name, o.total
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed';
```

### JOIN Order Optimization

**Small Table First Principle:**

```sql
-- ✅ OPTIMAL: Smaller table first
SELECT p.name, c.name
FROM products p  -- Assume products is smaller
JOIN categories c ON p.category_id = c.id
WHERE p.price > 100;

-- Query planner usually handles this, but you can force with explicit joins
```

**Multiple JOIN Optimization:**

```sql
-- ✅ EFFICIENT: Strategic join order and filtering
SELECT u.name, o.total, oi.quantity, p.name
FROM users u
JOIN orders o ON u.id = o.user_id
    AND o.created_date > CURRENT_DATE - INTERVAL '30 days'  -- Filter early
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE u.active = true;

-- Indexes needed:
-- users(id), users(active)
-- orders(user_id, created_date), orders(id)
-- order_items(order_id, product_id)
-- products(id)
```

### Semi-Join vs EXISTS

**Performance Comparison:**

```sql
-- Method 1: Semi-join with IN
SELECT * FROM users
WHERE id IN (SELECT user_id FROM orders WHERE total > 1000);

-- Method 2: EXISTS (often faster)
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.user_id = u.id AND o.total > 1000
);

-- Method 3: INNER JOIN with DISTINCT (least efficient)
SELECT DISTINCT u.* FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE o.total > 1000;
```

### Anti-Join Optimization

**NOT EXISTS vs NOT IN:**

```sql
-- ✅ PREFERRED: NOT EXISTS (handles NULLs correctly)
SELECT * FROM users u
WHERE NOT EXISTS (
    SELECT 1 FROM orders o WHERE o.user_id = u.id
);

-- ❌ PROBLEMATIC: NOT IN (issues with NULLs)
SELECT * FROM users
WHERE id NOT IN (SELECT user_id FROM orders);  -- Returns no rows if any user_id is NULL

-- ✅ SAFE NOT IN: With NULL handling
SELECT * FROM users
WHERE id NOT IN (SELECT user_id FROM orders WHERE user_id IS NOT NULL);
```

---

## 5. WHERE Clause Optimization

### Sargable Conditions

**Sargable (Search ARGument ABLE) Examples:**

```sql
-- ✅ SARGABLE: Can use indexes
SELECT * FROM orders WHERE created_date >= '2024-01-01';
SELECT * FROM users WHERE age BETWEEN 25 AND 35;
SELECT * FROM products WHERE price = 99.99;

-- ❌ NON-SARGABLE: Cannot use indexes efficiently
SELECT * FROM orders WHERE YEAR(created_date) = 2024;  -- Use: created_date >= '2024-01-01' AND created_date < '2025-01-01'
SELECT * FROM users WHERE age + 5 > 30;  -- Use: age > 25
SELECT * FROM products WHERE price * 1.1 > 100;  -- Use: price > 100/1.1
```

### Function Usage in WHERE

**Avoiding Functions on Columns:**

```sql
-- ❌ INEFFICIENT: Function on column
SELECT * FROM users WHERE UPPER(name) = 'JOHN DOE';

-- ✅ EFFICIENT: Expression index or rewrite query
CREATE INDEX idx_users_upper_name ON users(UPPER(name));
-- OR
SELECT * FROM users WHERE name = 'John Doe' OR name = 'JOHN DOE' OR name = 'john doe';

-- ❌ INEFFICIENT: Date function on column
SELECT * FROM orders WHERE DATE(created_at) = '2024-01-01';

-- ✅ EFFICIENT: Range condition
SELECT * FROM orders
WHERE created_at >= '2024-01-01'
  AND created_at < '2024-01-02';
```

### Compound Conditions

**AND vs OR Performance:**

```sql
-- ✅ EFFICIENT: AND conditions (can use multiple index columns)
SELECT * FROM users
WHERE age > 25
  AND city = 'New York'
  AND active = true;
-- Index: (age, city, active) or separate indexes

-- ❌ CHALLENGING: OR conditions (harder to optimize)
SELECT * FROM users
WHERE age > 65
   OR city = 'Retirement Village';
-- May require UNION or bitmap index scan

-- ✅ OPTIMIZED OR: Using UNION
SELECT * FROM users WHERE age > 65
UNION
SELECT * FROM users WHERE city = 'Retirement Village';
```

### NULL Handling

**NULL Comparisons:**

```sql
-- ✅ CORRECT: IS NULL / IS NOT NULL
SELECT * FROM users WHERE middle_name IS NULL;
SELECT * FROM users WHERE middle_name IS NOT NULL;

-- ❌ INCORRECT: = NULL doesn't work
SELECT * FROM users WHERE middle_name = NULL;  -- Returns no rows

-- ✅ PARTIAL INDEX for NULL handling
CREATE INDEX idx_users_non_null_middle ON users(middle_name)
WHERE middle_name IS NOT NULL;
```

### LIKE Pattern Optimization

**Wildcard Positioning:**

```sql
-- ✅ CAN USE INDEX: Leading characters specified
SELECT * FROM users WHERE name LIKE 'John%';

-- ❌ CANNOT USE B-TREE INDEX: Leading wildcard
SELECT * FROM users WHERE name LIKE '%John%';

-- ✅ SOLUTION: Use trigram index for pattern matching
CREATE EXTENSION pg_trgm;
CREATE INDEX idx_users_name_trgm ON users USING GIN(name gin_trgm_ops);
SELECT * FROM users WHERE name LIKE '%John%';  -- Now can use index

-- ✅ FULL-TEXT SEARCH for complex patterns
CREATE INDEX idx_users_name_fts ON users USING GIN(to_tsvector('english', name));
SELECT * FROM users WHERE to_tsvector('english', name) @@ to_tsquery('John');
```

---

## 6. Subquery vs JOIN Optimization

### Correlated vs Non-Correlated Subqueries

**Non-Correlated (Independent) Subqueries:**

```sql
-- ✅ EFFICIENT: Executed once
SELECT * FROM products
WHERE category_id IN (
    SELECT id FROM categories WHERE active = true
);

-- Alternative JOIN (often similar performance):
SELECT p.* FROM products p
JOIN categories c ON p.category_id = c.id
WHERE c.active = true;
```

**Correlated Subqueries:**

```sql
-- ❌ POTENTIALLY SLOW: Executed for each row
SELECT * FROM users u
WHERE (
    SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id
) > 5;

-- ✅ OPTIMIZED: Use JOIN with aggregation
SELECT DISTINCT u.* FROM users u
JOIN (
    SELECT user_id FROM orders
    GROUP BY user_id
    HAVING COUNT(*) > 5
) o ON u.id = o.user_id;
```

### EXISTS vs IN vs JOIN

**Performance Comparison:**

```sql
-- Method 1: EXISTS (good for checking existence)
SELECT * FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.customer_id = c.id
);

-- Method 2: IN (good when subquery returns small result set)
SELECT * FROM customers
WHERE id IN (SELECT DISTINCT customer_id FROM orders);

-- Method 3: JOIN (good when you need data from both tables)
SELECT DISTINCT c.* FROM customers c
JOIN orders o ON c.id = o.customer_id;

-- Performance rule: EXISTS ≈ IN < JOIN (for existence checks)
```

### Scalar Subqueries Optimization

**Avoiding Repeated Scalar Subqueries:**

```sql
-- ❌ INEFFICIENT: Multiple scalar subqueries
SELECT
    u.name,
    (SELECT COUNT(*) FROM orders WHERE user_id = u.id) as order_count,
    (SELECT MAX(total) FROM orders WHERE user_id = u.id) as max_order,
    (SELECT AVG(total) FROM orders WHERE user_id = u.id) as avg_order
FROM users u;

-- ✅ EFFICIENT: Single JOIN with aggregation
SELECT
    u.name,
    COALESCE(o.order_count, 0) as order_count,
    o.max_order,
    o.avg_order
FROM users u
LEFT JOIN (
    SELECT
        user_id,
        COUNT(*) as order_count,
        MAX(total) as max_order,
        AVG(total) as avg_order
    FROM orders
    GROUP BY user_id
) o ON u.id = o.user_id;
```

---

## 7. Aggregate Function Optimization

### GROUP BY Optimization

**Efficient Grouping:**

```sql
-- ✅ OPTIMAL: Group by indexed columns
SELECT user_id, COUNT(*), AVG(total)
FROM orders
GROUP BY user_id;  -- Ensure user_id is indexed

-- ✅ COMPOSITE INDEX for multiple GROUP BY columns
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
SELECT user_id, status, COUNT(*)
FROM orders
GROUP BY user_id, status;
```

**HAVING vs WHERE:**

```sql
-- ✅ EFFICIENT: Filter before grouping with WHERE
SELECT user_id, COUNT(*)
FROM orders
WHERE created_date > '2024-01-01'  -- Filter first
GROUP BY user_id
HAVING COUNT(*) > 5;  -- Then filter groups

-- ❌ LESS EFFICIENT: Only HAVING clause
SELECT user_id, COUNT(*)
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 5
  AND MIN(created_date) > '2024-01-01';  -- Should be in WHERE
```

### Window Functions vs GROUP BY

**When to Use Window Functions:**

```sql
-- Scenario: Get each order with user's total order count
-- ❌ LESS EFFICIENT: Self-join approach
SELECT o.*, user_stats.total_orders
FROM orders o
JOIN (
    SELECT user_id, COUNT(*) as total_orders
    FROM orders
    GROUP BY user_id
) user_stats ON o.user_id = user_stats.user_id;

-- ✅ MORE EFFICIENT: Window function
SELECT o.*,
       COUNT(*) OVER (PARTITION BY user_id) as total_orders
FROM orders o;
```

**Window Function Optimization:**

```sql
-- ✅ EFFICIENT: Reuse window definition
SELECT
    user_id,
    order_date,
    total,
    ROW_NUMBER() OVER user_window as row_num,
    SUM(total) OVER user_window as running_total,
    AVG(total) OVER user_window as avg_total
FROM orders
WINDOW user_window AS (PARTITION BY user_id ORDER BY order_date);

-- ❌ INEFFICIENT: Repeat window definition
SELECT
    user_id,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_date),
    SUM(total) OVER (PARTITION BY user_id ORDER BY order_date),
    AVG(total) OVER (PARTITION BY user_id ORDER BY order_date)
FROM orders;
```

### Aggregate Function Performance

**COUNT Optimization:**

```sql
-- ✅ FASTEST: COUNT(*) is optimized
SELECT COUNT(*) FROM orders;

-- ✅ FAST: COUNT(1) same as COUNT(*)
SELECT COUNT(1) FROM orders;

-- ❌ SLOWER: COUNT(column) must check for NULLs
SELECT COUNT(user_id) FROM orders;  -- Only if you need to exclude NULLs

-- ✅ APPROXIMATE COUNT for large tables (PostgreSQL 9.2+)
SELECT reltuples::bigint FROM pg_class WHERE relname = 'orders';
```

**DISTINCT Aggregates:**

```sql
-- ❌ POTENTIALLY SLOW: Multiple DISTINCT aggregates
SELECT
    COUNT(DISTINCT user_id) as unique_users,
    COUNT(DISTINCT product_id) as unique_products
FROM order_items;

-- ✅ ALTERNATIVE: Use window functions or subqueries
WITH unique_counts AS (
    SELECT
        COUNT(*) OVER (PARTITION BY user_id) as user_orders,
        COUNT(*) OVER (PARTITION BY product_id) as product_orders
    FROM order_items
)
SELECT
    COUNT(CASE WHEN user_orders = 1 THEN 1 END) as unique_users,
    COUNT(CASE WHEN product_orders = 1 THEN 1 END) as unique_products
FROM unique_counts;
```

---

## 8. LIMIT and OFFSET Optimization

### Pagination Optimization

**Basic LIMIT/OFFSET Issues:**

```sql
-- ❌ PROBLEMATIC: Large OFFSET values
SELECT * FROM orders
ORDER BY created_date DESC
LIMIT 20 OFFSET 10000;  -- Scans 10,020 rows to return 20

-- Performance degrades as OFFSET increases
```

**Cursor-Based Pagination:**

```sql
-- ✅ EFFICIENT: Cursor-based pagination
-- First page
SELECT * FROM orders
WHERE created_date <= '2024-01-01 12:00:00'
ORDER BY created_date DESC, id DESC
LIMIT 20;

-- Next page (using last row from previous page)
SELECT * FROM orders
WHERE (created_date < '2024-01-01 11:30:00')
   OR (created_date = '2024-01-01 11:30:00' AND id < 12345)
ORDER BY created_date DESC, id DESC
LIMIT 20;
```

**Keyset Pagination Implementation:**

```sql
-- ✅ OPTIMAL: Keyset pagination with composite key
CREATE INDEX idx_orders_date_id ON orders(created_date DESC, id DESC);

-- Page 1
SELECT id, created_date, total FROM orders
ORDER BY created_date DESC, id DESC
LIMIT 20;

-- Page 2 (last_date and last_id from page 1)
SELECT id, created_date, total FROM orders
WHERE (created_date, id) < ('2024-01-01 10:30:00', 12345)
ORDER BY created_date DESC, id DESC
LIMIT 20;
```

### TOP-N Queries

**Efficient TOP-N Patterns:**

```sql
-- ✅ SIMPLE: Direct LIMIT with ORDER BY
SELECT * FROM products
ORDER BY price DESC
LIMIT 10;

-- ✅ TOP-N per group using window functions
SELECT * FROM (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY price DESC) as rn
    FROM products
) ranked
WHERE rn <= 3;  -- Top 3 products per category

-- ✅ Alternative with LATERAL join
SELECT c.name, p.*
FROM categories c
CROSS JOIN LATERAL (
    SELECT * FROM products
    WHERE category_id = c.id
    ORDER BY price DESC
    LIMIT 3
) p;
```

---

## 9. Data Type Optimization

### Choosing Optimal Data Types

**Numeric Types:**

```sql
-- ✅ OPTIMAL: Choose smallest appropriate type
CREATE TABLE products (
    id SERIAL PRIMARY KEY,              -- 4 bytes, up to 2 billion
    price DECIMAL(10,2),                -- Exact decimal for money
    discount_percent SMALLINT,          -- 2 bytes, -32K to 32K
    quantity INTEGER,                   -- 4 bytes
    weight REAL                         -- 4 bytes float
);

-- ❌ WASTEFUL: Oversized types
CREATE TABLE products_bad (
    id BIGSERIAL PRIMARY KEY,           -- 8 bytes when 4 would suffice
    price NUMERIC(20,10),               -- Excessive precision
    discount_percent NUMERIC(5,2),      -- SMALLINT would work
    quantity BIGINT,                    -- 8 bytes for small numbers
    weight DOUBLE PRECISION             -- 8 bytes when 4 would suffice
);
```

**String Types:**

```sql
-- ✅ APPROPRIATE: Use VARCHAR with reasonable limits
CREATE TABLE users (
    username VARCHAR(50),               -- Enforces reasonable limit
    email VARCHAR(255),                 -- Standard email length
    bio TEXT,                          -- Variable length, no practical limit
    status CHAR(1)                     -- Fixed length for codes
);

-- ❌ PROBLEMATIC: No constraints or wrong types
CREATE TABLE users_bad (
    username TEXT,                      -- No length limit
    email TEXT,                        -- Wastes space for short emails
    bio VARCHAR(1000),                 -- Artificial limit on variable content
    status VARCHAR(20)                 -- Wastes space for single character
);
```

**Date/Time Types:**

```sql
-- ✅ CORRECT: Appropriate temporal types
CREATE TABLE events (
    created_at TIMESTAMP WITH TIME ZONE,    -- Full timestamp with timezone
    event_date DATE,                        -- Date only
    event_time TIME,                        -- Time only
    duration INTERVAL                       -- Time interval
);

-- ❌ INEFFICIENT: Wrong temporal types
CREATE TABLE events_bad (
    created_at VARCHAR(50),                 -- String instead of timestamp
    event_date TIMESTAMP,                   -- Timestamp when date suffices
    event_time TIMESTAMP,                   -- Timestamp for time only
    duration INTEGER                        -- Seconds instead of interval
);
```

### Boolean and Enum Types

**Boolean Optimization:**

```sql
-- ✅ OPTIMAL: Use actual BOOLEAN type
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    active BOOLEAN DEFAULT true,
    verified BOOLEAN DEFAULT false
);

-- Queries with proper boolean usage
SELECT * FROM users WHERE active;  -- Not WHERE active = true
SELECT * FROM users WHERE NOT verified;  -- Not WHERE verified = false

-- ❌ INEFFICIENT: Fake boolean columns
CREATE TABLE users_bad (
    id SERIAL PRIMARY KEY,
    active CHAR(1) CHECK (active IN ('Y', 'N')),  -- Wastes space
    verified INTEGER CHECK (verified IN (0, 1))   -- Unclear intent
);
```

**ENUM Types:**

```sql
-- ✅ EFFICIENT: ENUM for fixed set of values
CREATE TYPE order_status AS ENUM ('pending', 'processing', 'shipped', 'delivered', 'cancelled');

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    status order_status DEFAULT 'pending'
);

-- Benefits: Type safety, storage efficiency, clear documentation

-- ❌ ALTERNATIVES (less optimal):
CREATE TABLE orders_alt (
    status VARCHAR(20) CHECK (status IN ('pending', 'processing', 'shipped', 'delivered', 'cancelled'))
);
```

### Array and JSON Types

**Array Type Usage:**

```sql
-- ✅ GOOD USE CASE: Multiple values of same type
CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    tags TEXT[],
    ratings INTEGER[]
);

-- Efficient queries with array operators
SELECT * FROM posts WHERE tags @> ARRAY['postgresql'];
SELECT * FROM posts WHERE 'optimization' = ANY(tags);

-- Index for array operations
CREATE INDEX idx_posts_tags ON posts USING GIN(tags);
```

**JSON vs JSONB:**

```sql
-- ✅ PREFER JSONB: Better performance for queries
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    attributes JSONB  -- Use JSONB, not JSON
);

-- JSONB supports indexing
CREATE INDEX idx_products_attrs ON products USING GIN(attributes);

-- Efficient JSONB queries
SELECT * FROM products WHERE attributes @> '{"color": "red"}';
SELECT * FROM products WHERE attributes ? 'warranty';

-- ❌ AVOID JSON: Slower, no indexing support
CREATE TABLE products_bad (
    id SERIAL PRIMARY KEY,
    attributes JSON  -- Less efficient than JSONB
);
```

---

## 10. Table Structure Optimization

### Normalization vs Denormalization

**Proper Normalization:**

```sql
-- ✅ NORMALIZED: Reduces redundancy
CREATE TABLE customers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(255) UNIQUE
);

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(id),
    order_date DATE,
    total DECIMAL(10,2)
);

CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id),
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER,
    unit_price DECIMAL(10,2)
);
```

**Strategic Denormalization:**

```sql
-- ✅ DENORMALIZED: For read-heavy scenarios
CREATE TABLE order_summary (
    id SERIAL PRIMARY KEY,
    customer_id INTEGER,
    customer_name VARCHAR(100),     -- Denormalized
    customer_email VARCHAR(255),    -- Denormalized
    order_date DATE,
    total DECIMAL(10,2),
    item_count INTEGER              -- Denormalized
);

-- Maintain with triggers or application logic
CREATE OR REPLACE FUNCTION update_order_summary()
RETURNS TRIGGER AS $
BEGIN
    -- Update denormalized data when base tables change
    UPDATE order_summary
    SET customer_name = (SELECT name FROM customers WHERE id = NEW.customer_id)
    WHERE customer_id = NEW.customer_id;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;
```

### Partitioning Strategies

**Range Partitioning:**

```sql
-- ✅ RANGE PARTITIONING: For time-series data
CREATE TABLE sales (
    id SERIAL,
    sale_date DATE,
    amount DECIMAL(10,2),
    customer_id INTEGER
) PARTITION BY RANGE (sale_date);

-- Create partitions
CREATE TABLE sales_2024_q1 PARTITION OF sales
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');

CREATE TABLE sales_2024_q2 PARTITION OF sales
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');

CREATE TABLE sales_2024_q3 PARTITION OF sales
    FOR VALUES FROM ('2024-07-01') TO ('2024-10-01');

-- Indexes on each partition
CREATE INDEX idx_sales_2024_q1_date ON sales_2024_q1(sale_date);
CREATE INDEX idx_sales_2024_q1_customer ON sales_2024_q1(customer_id);
```

**Hash Partitioning:**

```sql
-- ✅ HASH PARTITIONING: For even distribution
CREATE TABLE user_sessions (
    id SERIAL,
    user_id INTEGER,
    session_data JSONB,
    created_at TIMESTAMP
) PARTITION BY HASH (user_id);

-- Create hash partitions
CREATE TABLE user_sessions_0 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE user_sessions_1 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);

CREATE TABLE user_sessions_2 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);

CREATE TABLE user_sessions_3 PARTITION OF user_sessions
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

**List Partitioning:**

```sql
-- ✅ LIST PARTITIONING: For categorical data
CREATE TABLE orders (
    id SERIAL,
    customer_id INTEGER,
    region VARCHAR(50),
    total DECIMAL(10,2)
) PARTITION BY LIST (region);

CREATE TABLE orders_north PARTITION OF orders
    FOR VALUES IN ('North', 'Northeast', 'Northwest');

CREATE TABLE orders_south PARTITION OF orders
    FOR VALUES IN ('South', 'Southeast', 'Southwest');

CREATE TABLE orders_other PARTITION OF orders DEFAULT;
```

### Column Storage Optimization

**Column Order Optimization:**

```sql
-- ✅ OPTIMAL: Order columns by size and access pattern
CREATE TABLE user_profiles (
    id BIGINT PRIMARY KEY,              -- 8 bytes, frequently accessed
    user_id INTEGER NOT NULL,           -- 4 bytes, frequently accessed
    last_login TIMESTAMP,               -- 8 bytes, frequently accessed
    is_active BOOLEAN DEFAULT true,     -- 1 byte, frequently accessed
    profile_data JSONB,                 -- Variable, less frequently accessed
    bio TEXT,                          -- Variable, less frequently accessed
    metadata TEXT                      -- Variable, rarely accessed
);

-- ❌ SUBOPTIMAL: Poor column ordering
CREATE TABLE user_profiles_bad (
    bio TEXT,                          -- Variable size first
    metadata TEXT,                     -- Another variable size
    is_active BOOLEAN,                 -- Small type in middle
    id BIGINT PRIMARY KEY,             -- Primary key not first
    profile_data JSONB,                -- Variable size mixed with fixed
    user_id INTEGER,                   -- Fixed size at end
    last_login TIMESTAMP               -- Fixed size at end
);
```

**FILLFACTOR Optimization:**

```sql
-- ✅ ADJUST FILLFACTOR: For tables with frequent updates
CREATE TABLE frequently_updated (
    id SERIAL PRIMARY KEY,
    status VARCHAR(20),
    last_modified TIMESTAMP,
    data TEXT
) WITH (FILLFACTOR = 80);  -- Leave 20% free space for updates

-- ✅ FULL FILLFACTOR: For read-only or append-only tables
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    action VARCHAR(50),
    timestamp TIMESTAMP,
    details JSONB
) WITH (FILLFACTOR = 100);  -- Maximize storage efficiency
```

### Constraints and Performance

**Primary Key Optimization:**

```sql
-- ✅ OPTIMAL: Serial or UUID primary keys
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,              -- Auto-incrementing, clustered
    -- OR
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- Distributed systems
    customer_id INTEGER,
    total DECIMAL(10,2)
);

-- ❌ PROBLEMATIC: Composite primary key when not needed
CREATE TABLE orders_bad (
    customer_id INTEGER,
    order_date DATE,
    order_number INTEGER,
    PRIMARY KEY (customer_id, order_date, order_number)  -- Unnecessarily complex
);
```

**Foreign Key Optimization:**

```sql
-- ✅ PROPER: Foreign keys with matching indexes
CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id),
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER
);

-- Create indexes for foreign keys
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_product_id ON order_items(product_id);

-- ✅ CASCADE OPTIONS: Choose appropriate actions
ALTER TABLE order_items
ADD CONSTRAINT fk_order_items_order
FOREIGN KEY (order_id) REFERENCES orders(id)
ON UPDATE CASCADE ON DELETE CASCADE;
```

**Check Constraints for Performance:**

```sql
-- ✅ HELPFUL: Check constraints enable constraint exclusion
CREATE TABLE sales_2024 (
    id SERIAL PRIMARY KEY,
    sale_date DATE CHECK (sale_date >= '2024-01-01' AND sale_date < '2025-01-01'),
    amount DECIMAL(10,2) CHECK (amount > 0)
);

-- Query planner can exclude tables based on constraints
SELECT * FROM sales_2024 WHERE sale_date >= '2023-01-01';  -- Won't scan table
```

---

## 11. Advanced Optimization Techniques

### Materialized Views

**Creating Materialized Views:**

```sql
-- ✅ MATERIALIZED VIEW: For expensive aggregations
CREATE MATERIALIZED VIEW monthly_sales_summary AS
SELECT
    DATE_TRUNC('month', order_date) as month,
    COUNT(*) as order_count,
    SUM(total) as total_revenue,
    AVG(total) as avg_order_value,
    COUNT(DISTINCT customer_id) as unique_customers
FROM orders
WHERE order_date >= '2023-01-01'
GROUP BY DATE_TRUNC('month', order_date);

-- Create index on materialized view
CREATE INDEX idx_monthly_sales_month ON monthly_sales_summary(month);

-- Refresh strategies
REFRESH MATERIALIZED VIEW monthly_sales_summary;  -- Blocking refresh
REFRESH MATERIALIZED VIEW CONCURRENTLY monthly_sales_summary;  -- Non-blocking (requires unique index)
```

**Incremental Refresh Pattern:**

```sql
-- ✅ INCREMENTAL REFRESH: Custom implementation
CREATE TABLE sales_summary_log (
    refresh_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_processed_id BIGINT
);

-- Refresh function
CREATE OR REPLACE FUNCTION refresh_sales_summary()
RETURNS VOID AS $
DECLARE
    last_id BIGINT;
BEGIN
    SELECT COALESCE(MAX(last_processed_id), 0) INTO last_id
    FROM sales_summary_log;

    -- Update summary with new data
    INSERT INTO sales_summary
    SELECT /* aggregation logic */
    FROM orders
    WHERE id > last_id;

    -- Log the refresh
    INSERT INTO sales_summary_log(last_processed_id)
    SELECT MAX(id) FROM orders;
END;
$ LANGUAGE plpgsql;
```

### Partial Indexes

**Conditional Indexes:**

```sql
-- ✅ PARTIAL INDEX: Index only relevant rows
CREATE INDEX idx_orders_pending ON orders(created_date)
WHERE status = 'pending';

CREATE INDEX idx_users_active_email ON users(email)
WHERE active = true;

CREATE INDEX idx_products_discounted ON products(discount_percent)
WHERE discount_percent > 0;

-- Query must match the condition
SELECT * FROM orders
WHERE status = 'pending'
  AND created_date > '2024-01-01';  -- Uses partial index
```

**Expression Indexes:**

```sql
-- ✅ EXPRESSION INDEX: For functional queries
CREATE INDEX idx_users_lower_email ON users(lower(email));
SELECT * FROM users WHERE lower(email) = 'john@example.com';

CREATE INDEX idx_orders_month ON orders(DATE_TRUNC('month', created_date));
SELECT * FROM orders WHERE DATE_TRUNC('month', created_date) = '2024-01-01';

-- Complex expressions
CREATE INDEX idx_products_profit_margin ON products((price - cost) / price * 100);
SELECT * FROM products WHERE (price - cost) / price * 100 > 20;
```

### Query Hints and Plan Forcing

**Configuration Parameters:**

```sql
-- ✅ SESSION-LEVEL TUNING: Adjust for specific queries
SET work_mem = '256MB';                    -- Increase for large sorts/hashes
SET random_page_cost = 1.1;               -- SSD storage optimization
SET effective_cache_size = '8GB';         -- Available system cache

-- Query-specific adjustments
SET LOCAL enable_seqscan = false;         -- Force index usage
SET LOCAL enable_nestloop = false;       -- Disable nested loops
```

**Forcing Query Plans:**

```sql
-- ✅ PLAN HINTS: Using pg_hint_plan extension
/*+
  IndexScan(orders idx_orders_date)
  HashJoin(orders customers)
  Leading(customers orders)
*/
SELECT o.*, c.name
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE o.order_date > '2024-01-01';
```

### Parallel Query Optimization

**Parallel Query Configuration:**

```sql
-- ✅ PARALLEL SETTINGS: Optimize for your hardware
SET max_parallel_workers_per_gather = 4;  -- CPU cores available
SET parallel_tuple_cost = 0.1;           -- Cost of parallel communication
SET parallel_setup_cost = 1000.0;        -- Setup cost for parallel queries

-- Force parallel execution
SET force_parallel_mode = on;            -- Development/testing only
```

**Parallel-Safe Functions:**

```sql
-- ✅ PARALLEL-SAFE: Mark custom functions appropriately
CREATE OR REPLACE FUNCTION calculate_tax(amount DECIMAL)
RETURNS DECIMAL AS $
BEGIN
    RETURN amount * 0.08;
END;
$ LANGUAGE plpgsql PARALLEL SAFE;       -- Enables parallel execution
```

### Common Table Expressions (CTE) Optimization

**CTE vs Subquery Performance:**

```sql
-- ✅ CTE: Good for readability and reuse
WITH high_value_customers AS (
    SELECT customer_id, SUM(total) as total_spent
    FROM orders
    WHERE order_date > '2024-01-01'
    GROUP BY customer_id
    HAVING SUM(total) > 10000
),
customer_orders AS (
    SELECT hvc.customer_id, COUNT(*) as order_count
    FROM high_value_customers hvc
    JOIN orders o ON hvc.customer_id = o.customer_id
    GROUP BY hvc.customer_id
)
SELECT * FROM customer_orders;

-- ❌ MATERIALIZED CTE: Prevents optimization
WITH high_value_customers AS MATERIALIZED (  -- Forces materialization
    SELECT customer_id, SUM(total) as total_spent
    FROM orders
    GROUP BY customer_id
    HAVING SUM(total) > 10000
)
SELECT * FROM high_value_customers;
```

**Recursive CTE Optimization:**

```sql
-- ✅ RECURSIVE CTE: For hierarchical data
WITH RECURSIVE category_tree AS (
    -- Base case
    SELECT id, name, parent_id, 1 as level
    FROM categories
    WHERE parent_id IS NULL

    UNION ALL

    -- Recursive case
    SELECT c.id, c.name, c.parent_id, ct.level + 1
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
    WHERE ct.level < 10  -- Prevent infinite recursion
)
SELECT * FROM category_tree;
```

---

## 12. Monitoring and Analysis Tools

### Performance Monitoring

**Query Performance Statistics:**

```sql
-- ✅ ENABLE QUERY STATISTICS: Track query performance
-- In postgresql.conf
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.max = 10000
pg_stat_statements.track = all

-- Create extension
CREATE EXTENSION pg_stat_statements;

-- View top queries by total time
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    rows,
    100.0 * shared_blks_hit / nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 20;
```

**Index Usage Monitoring:**

```sql
-- ✅ MONITOR INDEX USAGE: Find unused indexes
SELECT
    schemaname,
    tablename,
    indexname,
    idx_tup_read,
    idx_tup_fetch,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY pg_relation_size(indexrelid) DESC;

-- Index hit ratio
SELECT
    schemaname,
    tablename,
    indexname,
    idx_blks_read,
    idx_blks_hit,
    round(100.0 * idx_blks_hit / nullif(idx_blks_hit + idx_blks_read, 0), 2) as hit_ratio
FROM pg_stat_user_indexes
WHERE idx_blks_hit + idx_blks_read > 0
ORDER BY hit_ratio;
```

**Table Statistics:**

```sql
-- ✅ TABLE STATISTICS: Monitor table access patterns
SELECT
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch,
    n_tup_ins,
    n_tup_upd,
    n_tup_del,
    n_tup_hot_upd,
    pg_size_pretty(pg_total_relation_size(relid)) as total_size
FROM pg_stat_user_tables
ORDER BY seq_scan DESC;

-- Tables with high sequential scan ratio
SELECT
    schemaname,
    tablename,
    seq_scan,
    idx_scan,
    round(100.0 * seq_scan / nullif(seq_scan + idx_scan, 0), 2) as seq_scan_ratio
FROM pg_stat_user_tables
WHERE seq_scan + idx_scan > 100
ORDER BY seq_scan_ratio DESC;
```

### VACUUM and ANALYZE Optimization

**VACUUM Strategies:**

```sql
-- ✅ REGULAR VACUUM: Prevent table bloat
VACUUM ANALYZE users;                     -- Standard vacuum with stats update
VACUUM (VERBOSE, ANALYZE) large_table;    -- Verbose output
VACUUM FULL large_table;                  -- Full vacuum (requires exclusive lock)

-- Autovacuum configuration
ALTER TABLE high_update_table SET (
    autovacuum_vacuum_scale_factor = 0.1,    -- Vacuum when 10% of table is dead
    autovacuum_analyze_scale_factor = 0.05,  -- Analyze when 5% of table changes
    autovacuum_vacuum_cost_delay = 10        -- Reduce vacuum impact
);
```

**ANALYZE for Query Planning:**

```sql
-- ✅ UPDATE STATISTICS: Keep planner statistics current
ANALYZE;                                  -- All tables
ANALYZE users;                           -- Specific table
ANALYZE users(email, created_date);      -- Specific columns

-- Manual statistics targets
ALTER TABLE large_table ALTER COLUMN indexed_column SET STATISTICS 1000;
```

### Bloat Monitoring

**Table Bloat Detection:**

```sql
-- ✅ BLOAT MONITORING: Check table bloat
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(relid)) as size,
    pg_size_pretty(pg_relation_size(relid)) as table_size,
    round(100 * pg_relation_size(relid)::numeric / pg_total_relation_size(relid), 2) as table_ratio,
    n_dead_tup,
    n_live_tup,
    round(100.0 * n_dead_tup / nullif(n_live_tup + n_dead_tup, 0), 2) as dead_ratio
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY dead_ratio DESC;
```

**Index Bloat Detection:**

```sql
-- ✅ INDEX BLOAT: Monitor index efficiency
SELECT
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    CASE
        WHEN idx_scan = 0 THEN 'Never used'
        WHEN idx_tup_read = 0 THEN 'Index only scans'
        ELSE round(100.0 * idx_tup_fetch / idx_tup_read, 2)::text || '% heap fetches'
    END as efficiency
FROM pg_stat_user_indexes
ORDER BY pg_relation_size(indexrelid) DESC;
```

### Connection and Lock Monitoring

**Active Query Monitoring:**

```sql
-- ✅ ACTIVE QUERIES: Monitor currently running queries
SELECT
    pid,
    now() - pg_stat_activity.query_start AS duration,
    query,
    state,
    wait_event_type,
    wait_event
FROM pg_stat_activity
WHERE state = 'active'
  AND query NOT LIKE '%pg_stat_activity%'
ORDER BY duration DESC;

-- Long-running queries
SELECT
    pid,
    user,
    client_addr,
    query_start,
    now() - query_start as duration,
    substring(query, 1, 100) as query_snippet
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - query_start > interval '5 minutes'
ORDER BY duration DESC;
```

**Lock Monitoring:**

```sql
-- ✅ LOCK ANALYSIS: Detect blocking queries
SELECT
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

---

## Summary: Quick Reference Checklist

### ✅ DO's

- **Always use EXPLAIN ANALYZE** to understand query execution
- **Index foreign key columns** and frequently queried columns
- **Use composite indexes** with proper column ordering (most selective first)
- **Choose appropriate data types** (smallest that fits your data)
- **Use partial indexes** for filtered queries
- **Prefer EXISTS over IN** for existence checks
- **Use LIMIT with ORDER BY** for top-N queries
- **Implement cursor-based pagination** for large result sets
- **Monitor query performance** with pg_stat_statements
- **Keep statistics current** with regular ANALYZE
- **Use materialized views** for expensive aggregations
- **Partition large tables** by appropriate keys
- **Use prepared statements** for repeated queries

### ❌ DON'Ts

- **Don't use SELECT \*** unless you need all columns
- **Don't use functions on columns** in WHERE clauses without expression indexes
- **Don't ignore NULL handling** in comparisons and indexes
- **Don't use OFFSET** for large pagination
- **Don't create indexes on every column**
- **Don't use correlated subqueries** when JOINs perform better
- **Don't use VARCHAR without length limits** for bounded data
- **Don't ignore foreign key indexes**
- **Don't use UNION when UNION ALL suffices**
- **Don't use LIKE with leading wildcards** without trigram indexes

### Common Pitfalls to Avoid

1. **Index column order mismatch** with query WHERE clauses
2. **Implicit type conversions** causing index scans to be skipped
3. **OR conditions** preventing index usage
4. **Function calls on indexed columns** without expression indexes
5. **Large OFFSET values** in pagination
6. **Missing foreign key indexes** causing slow JOINs
7. **Outdated table statistics** leading to poor query plans
8. **Excessive indexing** slowing down INSERT/UPDATE operations
9. **Wrong data types** wasting storage and memory
10. **Ignoring connection pooling** and connection limits

This comprehensive guide covers all major aspects of PostgreSQL query optimization. Practice these techniques systematically, always measure performance before and after changes, and remember that optimization is an iterative process. Each database workload is unique, so adapt these principles to your specific use case.
